# Система Подбора Кандидатов на Основе ИИ: Документация для Разработчиков

## 1. Введение

Этот документ предоставляет техническую информацию и рекомендации для разработчиков, участвующих в создании и поддержке Системы подбора кандидатов. Система предназначена для автоматизации и повышения эффективности процесса поиска и оценки кандидатов на открытые вакансии.

## 2. Начало Работы

### 2.1. Системные Требования
*   Python (рекомендуется версия 3.8 или выше)
*   Poetry (для управления зависимостями и виртуальным окружением)
*   Git (для контроля версий)

### 2.2. Настройка Окружения
1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/Leonn-Leon/uniweb-cv-match-fast-fix
    cd uniweb-cv-match-fast-fix
    ```
2.  **Установите зависимости:**
    Проект использует Poetry для управления зависимостями. Выполните следующую команду в корневой директории проекта:
    ```bash
    poetry install
    ```
    Эта команда создаст виртуальное окружение (если оно еще не создано) и установит все пакеты, определенные в файлах `pyproject.toml` и `poetry.lock`.

    **Примечание о `requirements.txt`**: Файл `requirements.txt` в корне проекта генерируется автоматически и предназначен для обеспечения совместимости с платформами развертывания, такими как Streamlit Cloud. **Для локальной разработки всегда используйте `poetry install`**. Если вы добавляете новые зависимости с помощью `poetry add <package>`, не забудьте перегенерировать `requirements.txt` перед развертыванием:
    ```bash
    poetry export -f requirements.txt --output requirements.txt --without-hashes
    ```

### 2.3. Запуск Приложения Локально
Для запуска веб-приложения Streamlit выполните:
```bash
streamlit run app.py
```
Приложение должно автоматически открыться в вашем веб-браузере по умолчанию.

## 3. Архитектура Приложения

Система построена на базе фреймворка Streamlit для создания интерактивного пользовательского интерфейса и включает следующие ключевые компоненты:

### 3.1. Основной Скрипт Приложения (`app.py`)

`app.py` является точкой входа и главным управляющим скриптом веб-приложения. Его основные обязанности:

*   **Инициализация Состояния:** Управляет состоянием приложения с помощью `st.session_state`. Это включает:
    *   Флаг `computed`: Отслеживает, были ли выполнены расчеты по подбору.
    *   Настройки из UI: Режим "Вахта", опции фильтрации по расстоянию, пороги отсечения, веса признаков.
*   **Загрузка Ресурсов:**
    *   Загружает конфигурационный файл (например, `config_mass.yaml`) для моделей.
    *   Инициализирует соответствующую модель-селектор (например, `MassSelector`) с помощью утилиты `load_model`.
    *   Загружает данные кандидатов (например, из `candidates_hh.csv`) с помощью `load_data`.
    *   Обрабатывает возможные ошибки при загрузке ресурсов.
*   **Управление Режимами Работы:** В текущей реализации основной режим – массовый подбор (`Mode.MASS`). Архитектура предусматривает возможность расширения другими режимами (например, `Mode.PROF`).
*   **Отрисовка Пользовательского Интерфейса (UI):**
    *   **Боковая Панель:** Отображает общие настройки с помощью `common_ui.display_sidebar()`. Включает:
        *   Редактирование весов для второго этапа ранжирования.
        *   Чекбокс "Вахта" с колбэком `update_address_weight_callback`, который динамически изменяет вес признака "Адрес".
        *   Фильтры по дате обновления резюме и максимальному расстоянию.
        *   Слайдер для установки порога отсечения для второго этапа.
    *   **Основная Область:** Для режима массового подбора отображает форму ввода данных вакансии с помощью `mass_ui.display_mass_input_form()`.
*   **Запуск Процесса Подбора:**
    *   Активируется по нажатию кнопки "Подобрать".
    *   Проверяет заполнение обязательных полей вакансии.
    *   Извлекает актуальные настройки из `st.session_state`.
    *   Вызывает `selector.preprocess_vacancy()` для предобработки данных вакансии.
    *   **Кэширование:** Реализована логика кэширования промежуточных результатов (например, `./tmp_cvs.csv`, `./tmp_vac.json`, `./tmp_mask.npy`) для ускорения повторных запусков в режиме разработки (не "prod").
    *   **Выполнение Ранжирования (если кэш не используется):**
        1.  **Первый этап:** Вызывает `selector.rank_first_stage()`, передавая обработанную вакансию, DataFrame кандидатов и фильтры (дата, вахта, расстояние).
        2.  **Второй этап:** Вызывает `selector.rank_second_stage()`, передавая результаты первого этапа, обработанную вакансию, **актуальные веса из UI (`st.session_state["df_weights"]`)** и порог отсечения из UI.
    *   Сохраняет финальные результаты (словарь кандидатов, предобработанную вакансию, маску `nan_mask`) в `st.session_state`.
    *   Устанавливает `st.session_state["computed"] = True` и вызывает `st.rerun()` для обновления UI.
*   **Отображение Результатов:** Если `st.session_state["computed"]` истинно, извлекает результаты из `st.session_state` и отображает их с помощью `mass_ui.display_mass_results()`.

### 3.2. Модули Исходного Кода (`src/`)

#### 3.2.1. Модели Подбора (`src/models/`)
Отвечают за основную логику оценки и ранжирования кандидатов.

*   **`base_model.py`**: Определяет абстрактный базовый класс `BaseSelector`, задающий интерфейс для всех моделей подбора (методы `preprocess_vacancy`, `preprocess_cvs`, `rank_first_stage`, `rank_second_stage`).
*   **`mass_model.py`**:
    *   Содержит класс `MassSelector`, реализующий двухэтапный алгоритм массового подбора.
    *   **`preprocess_vacancy`**: Извлекает структурированную информацию из текста вакансии (адрес, график, навыки, опыт и т.д.) с помощью LLM/API (`find_info`), геокодирует адрес (`get_coords`).
    *   **`preprocess_cvs`**: Аналогично обрабатывает резюме кандидатов, извлекая структурированные данные.
    *   **`rank_first_stage`**: Выполняет начальную фильтрацию и грубое ранжирование кандидатов по дате, доступности, расстоянию (с геокодированием), готовности к переезду и релевантности должности (BM25 + эмбеддинги).
    *   **`rank_second_stage`**: Производит детальное ранжирование топ-кандидатов с первого этапа. Рассчитывает схожесть по множеству признаков (определенных в `config`) с использованием эмбеддингов (`self.embedder`) и специализированных LLM-промптов (`match_prompt`). Применяет настраиваемые веса из UI (`df_weights`) для расчета итогового балла (`sim_score_second`).
*   **`prof_model.py`**: Содержит класс `ProfSelector` для профессионального подбора (детальный анализ навыков). В настоящее время менее развит.

#### 3.2.2. Компоненты Пользовательского Интерфейса (`src/ui/`)
Модули, отвечающие за отрисовку различных частей UI с помощью Streamlit.

*   **`common_ui.py`**:
    *   Реализует общие элементы UI, в первую очередь, боковую панель (`display_sidebar`).
    *   Включает редактор весов признаков (`st.data_editor`), фильтры по дате, порогу соответствия, опции расстояния и чекбокс "Вахта".
    *   Взаимодействует с `st.session_state` для хранения и обновления настроек.
*   **`mass_ui.py`**:
    *   Содержит UI-компоненты, специфичные для режима массового подбора.
    *   `display_mass_input_form()`: Форма для ввода данных вакансии.
    *   `display_mass_results()`: Отображение результатов подбора в виде карточек кандидатов с детализацией по признакам и оценками совпадения.
*   **`prof_ui.py`**: UI-компоненты для режима профессионального подбора (может быть заглушкой или в разработке).

#### 3.2.3. Вспомогательные Утилиты (`src/utils/`)
Содержат общие вспомогательные функции, используемые в различных частях приложения.

*   **`utils.py`**:
    *   `load_data()`: Загрузка данных (например, из CSV).
    *   `load_model()`: Загрузка и инициализация моделей на основе конфигурационных файлов.
    *   `format_intersection()`: Форматирование текста для выделения совпадений.
    *   `select_color()`: Выбор цвета для визуализации оценок.
    *   `Mode` (Enum): Определение режимов работы приложения.
    *   Может содержать функции для взаимодействия с внешними API (например, OpenAI).
*   **`request_api.py`**:
    *   Содержит класс `Embedder` для генерации текстовых эмбеддингов.
    *   Поддерживает получение эмбеддингов через OpenAI API (с логикой повторных запросов) и локальные модели `sentence-transformers`.
    *   Использует `ThreadPoolExecutor` для параллельной пакетной обработки.
    *   Реализует персистентное кэширование эмбеддингов для оптимизации производительности.
*   **`create_embeddings.py`**:
    *   Скрипт для предварительного вычисления и кэширования эмбеддингов для больших наборов текстовых данных (например, из CSV-файла).
    *   Использует `Embedder` для генерации и сохранения эмбеддингов.
*   **`hardcode_data.py`** (или аналогичный):
    *   Может содержать статические данные, такие как `map_names` (словарь для отображения системных имен признаков в человекочитаемом виде).

### 3.3. Конфигурационные Файлы (`configs/`)
Хранят конфигурации для моделей и других компонентов системы (например, в формате YAML). Определяют параметры для этапов ранжирования, используемые признаки, их веса по умолчанию и т.д.

### 3.4. Данные (`data/`)
Каталог для хранения исходных данных, таких как CSV-файлы с резюме кандидатов:
 * `candidates_new_big.csv` - много данных с только авито
 * `candidates_hh.csv` - кандидаты с авито и hh.ru

## 4. Работа с Моделями

*   Все модели наследуются от базового класса `BaseSelector` из `src/models/base_model.py`, что обеспечивает единый интерфейс.
*   Каждая модель (например, `MassSelector`, `ProfSelector`) реализует специфическую логику оценки и ранжирования.
*   Модели загружаются и инициализируются в `app.py` с помощью функции `load_model()` из `src/utils/utils.py`, которая использует конфигурационные файлы из каталога `configs/`.
*   Ключевым элементом моделей является использование эмбеддингов для семантического сравнения текстов и, возможно, LLM-промптов для более сложных оценок.

## 5. Работа с Компонентами UI

*   Пользовательский интерфейс построен с использованием библиотеки Streamlit.
*   Общие элементы UI, такие как боковая панель настроек, вынесены в `src/ui/common_ui.py`.
*   UI-компоненты, специфичные для конкретного режима работы (например, массовый подбор), находятся в соответствующих файлах (например, `src/ui/mass_ui.py`).
*   Взаимодействие между UI-компонентами и основной логикой приложения (`app.py`) осуществляется через:
    *   `st.session_state` для хранения и обмена данными о состоянии и настройках.
    *   Вызовы функций из UI-модулей для отрисовки элементов.
    *   Колбэк-функции для обработки действий пользователя (например, изменение чекбокса "Вахта").