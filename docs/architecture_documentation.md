
# Архитектурная документация

Этот документ описывает архитектуру Системы подбора кандидатов на основе ИИ.

## 1. Обзор

Система представляет собой веб-приложение, предназначенное для сопоставления кандидатов с вакансиями. Она построена **полностью** на Python с использованием фреймворка Streamlit для пользовательского интерфейса. Архитектура подчеркивает модульность, позволяя интегрировать различные модели подбора и компоненты UI.

## 2. Высокоуровневая архитектура

Систему можно условно разделить на следующие логические уровни:


+--------------------------------+  
| Пользовательский интерфейс (UI) | (Streamlit: app.py, src/ui/)  
+--------------------------------+  
^ |  
| | Ввод пользователя / Отображение результатов  
| v  
+--------------------------------+  
| Логика приложения и |  
| Оркестрация | (app.py)  
+--------------------------------+  
^ |  
| | Вызов моделей / Обработка данных  
| v  
+--------------------------------+  
| Модели подбора | (src/models/)  
+--------------------------------+  
^ |  
| | Использование утилит / Доступ к данным  
| v  
+--------------------------------+ +----------------------+  
| Утилиты и Доступ к данным |---->| Источники данных |
| (src/utils/*, src/configs) | | (CSV, Конфиги YAML) |  
+--------------------------------+ +----------------------+  
|  
| Опциональное взаимодействие с внешними сервисами  
v  
+--------------------------------+  
| OpenAI API |  
| Яндекс.Карты API (Геокодирование) |  
+--------------------------------+  

## 3. Декомпозиция компонентов

### 3.1. Уровень представления (UI)

*   **`app.py` (Основное приложение):**
    *   Служит центральным координатором и основным скриптом приложения Streamlit.
    *   Управляет состоянием приложения (`st.session_state`).
    *   **В текущей реализации преимущественно ориентирован на режим "Массовый подбор". Логика для "Профессионального" режима не полностью реализована.**
    *   Интегрирует компоненты UI из `src/ui/`.
    *   Отображает поля ввода для деталей вакансии и выводит информацию о подобранных кандидатах.
*   **`src/ui/common_ui.py`:**
    *   Предоставляет общие элементы UI, используемые в разных режимах, такие как боковая панель настроек (`display_sidebar`), элементы управления для настройки весов, выбор дат и фильтры по расстоянию.
*   **`src/ui/mass_ui.py`:**
    *   Содержит компоненты UI, специфичные для режима массового подбора. Это включает форму для ввода данных вакансии (`display_mass_input_form`) (должность, требования, местоположение) и структурированное отображение совпадений кандидатов с деталями сравнения (`display_mass_results`).
*   **`src/ui/prof_ui.py`:**
    *   Предназначен для компонентов UI, специфичных для профессионального подбора. В настоящее время находится на стадии заглушки/разработки.

### 3.2. Уровень логики приложения и оркестрации

*   **`app.py` (Аспекты контроллера):**
    *   Получает ввод пользователя из UI.
    *   Инициализирует и вызывает соответствующие модели подбора (в текущей версии, в основном, `MassSelector`).
    *   Управляет двухэтапным процессом отбора: предварительная фильтрация, за которой следует детальный, взвешенный анализ.
    *   Передает данные между UI и моделями.
    *   Обрабатывает кэширование промежуточных результатов для оптимизации производительности **во время разработки/отладки**.

### 3.3. Уровень моделей подбора

*   **`src/models/base_model.py`:**
    *   Определяет абстрактный базовый класс (`BaseSelector`) для всех моделей подбора, обеспечивая общий интерфейс для предварительной обработки вакансий и резюме, а также для двух этапов ранжирования.
*   **`src/models/mass_model.py` (`MassSelector`):**
    *   Специализированная модель для массового подбора.
    *   Реализует двухэтапную оценку:
        *   **Первый этап:** Быстрый начальный фильтр (дата, доступность, география, должность по BM25 и эмбеддингам).
        *   **Второй этап:** Более детальный взвешенный скоринг по множеству признаков с использованием эмбеддингов и LLM-промптов.
    *   Включает логику для обработки специфических функций, таких как "вахтовый режим" и фильтрация по расстоянию (с использованием геокодирования через внешние API, если настроено).
*   **`src/models/prof_model.py` (`ProfSelector`):**
    *   Разработана для углубленного анализа профессиональных кандидатов.
    *   Фокусируется на детальной оценке навыков, опыта и других профессиональных квалификаций.
    *   Может использовать более сложные алгоритмы для анализа текста и сопоставления навыков. **В текущей реализации может быть менее развита, чем `MassSelector`.**

### 3.4. Уровень утилит и доступа к данным

*   **`src/utils/utils.py`:**
    *   Набор ключевых вспомогательных функций:
        *   `load_data()`: Загружает данные кандидатов из CSV-файлов.
        *   `load_model()`: Инициализирует и загружает модели подбора, используя конфигурационные файлы YAML из `src/configs/`.
        *   `format_intersection()`: Форматирует текст для выделения совпадающих ключевых слов между вакансией и резюме.
        *   `select_color()`: Определяет цветовую кодировку UI на основе оценок соответствия.
        *   Перечисление `Mode`: Определяет режимы работы приложения.
    *   Может содержать функции для взаимодействия с внешними API (например, OpenAI, Яндекс.Карты).
*   **`src/utils/request_api.py` (`Embedder`):**
    *   Предоставляет класс для генерации текстовых эмбеддингов с поддержкой OpenAI API и локальных `sentence-transformers`.
    *   Включает кэширование эмбеддингов и параллельную обработку.
*   **`src/utils/create_embeddings.py`:**
    *   Скрипт для предварительного создания и кэширования эмбеддингов для датасетов.
*   **`src/utils/hardcode_data.py`:**
    *   Содержит статические данные, такие как `map_names` для отображения человекочитаемых названий признаков.

### 3.5. Источники данных

*   **Данные кандидатов:** Хранятся в CSV-файлах (например, в `data/`), загружаются через `src/utils/utils.py`.
*   **Конфигурационные файлы:** YAML-файлы в `src/configs/`, используемые для настройки параметров моделей, загружаются через `src/utils/utils.py`.

### 3.6. Внешние сервисы

*   **OpenAI API:** Может использоваться моделями (через `src/utils/request_api.py` или напрямую) для генерации эмбеддингов, выполнения продвинутых задач НЛП (извлечение навыков, суммаризация).
*   **Яндекс.Карты API (или аналоги):** Используется в `src/models/mass_model.py` (через `src/utils/utils.py`) для геокодирования адресов и расчета расстояний.

## 4. Поток данных (Пример: Массовый подбор)

1.  **Взаимодействие с пользователем:**
    *   Пользователь **(по умолчанию)** находится в режиме "Массовый подбор" в `app.py`.
    *   Пользователь заполняет детали вакансии (должность, требования, местоположение и т.д.) с помощью элементов UI из `src/ui/mass_ui.py` (`display_mass_input_form`).
    *   Пользователь настраивает веса скоринга и фильтры в `src/ui/common_ui.py` (`display_sidebar`).
2.  **Оркестрация приложения (`app.py`):**
    *   `app.py` собирает введенные данные и настройки из `st.session_state`.
    *   Вызывает `src/utils/utils.py/load_model()` для инициализации модели `MassSelector` с конфигурацией из `src/configs/`.
    *   Вызывает `src/utils/utils.py/load_data()` для загрузки данных кандидатов (например, из `data/candidates_hh.csv`).
3.  **Обработка моделью (`src/models/mass_model.py`):**
    *   `MassSelector` получает детали вакансии (после `preprocess_vacancy`) и данные кандидатов.
    *   **Этап 1 (`rank_first_stage`):** Применяет базовые фильтры (дата, доступность, география, релевантность должности).
    *   **Этап 2 (`rank_second_stage`):** Для кандидатов, прошедших Этап 1, выполняет детальное сравнение с критериями вакансии, применяя заданные пользователем веса. Использует `self.embedder` и `match_prompt`.
    *   Модель возвращает ранжированный список подобранных кандидатов (словарь `data_cv_dict`), предобработанную вакансию (`vacancy_prep`) и маску невалидных полей вакансии (`nan_mask`).
4.  **Отображение результатов:**
    *   `app.py` получает результаты от модели и сохраняет их в `st.session_state`.
    *   Использует `src/ui/mass_ui.py/display_mass_results()` для отображения подобранных кандидатов, их оценок и детальных сравнений. Для форматирования и цветовой кодировки используются утилиты `format_intersection` и `select_color` из `src/utils/utils.py`.

## 5. Ключевые проектные решения

*   **Streamlit для UI:** Выбран для быстрой разработки интерактивных веб-приложений, управляемых данными.
*   **Модульный дизайн:** Разделение ответственности между UI, логикой приложения, моделями и утилитами облегчает поддержку и расширение.
*   **Настраиваемые модели и веса:** Обеспечивает гибкость для адаптации процесса подбора к различным ролям и приоритетам (особенно через UI в `common_ui.py`).
*   **Двухэтапный отбор (Режим массового подбора):** Оптимизирует производительность для больших наборов данных за счет сокращения числа кандидатов, подвергающихся детальному анализу.
*   **Кэширование:**
    *   **Streamlit кэширование (`@st.cache_data`, `@st.cache_resource`):** Используется для функций, результаты которых можно безопасно кэшировать (например, загрузка данных, инициализация моделей).
    *   **Кэширование эмбеддингов (`src/utils/request_api.py`):** Для избежания повторных вызовов API и вычислений эмбеддингов.
    *   **Промежуточное кэширование результатов в `app.py`:** Для ускорения процесса разработки/отладки путем сохранения результатов этапов подбора во временные файлы.

## 6. Масштабируемость и производительность

*   **Кэширование:** Ключевой элемент для производительности (см. пункт 5).
*   **Оптимизированная обработка данных:** Использование векторизованных операций Pandas, где это возможно, и эффективных алгоритмов в моделях (`mass_model.py`).
*   **Параллельная обработка:** Использование `ThreadPoolExecutor` в `src/utils/request_api.py` для пакетной генерации эмбеддингов.
*   Для очень больших наборов данных (превышающих возможности Pandas и локальной памяти) могут потребоваться дальнейшие оптимизации, такие как использование более масштабируемых библиотек для обработки данных (например, Dask, Polars) или переход на более надежную бэкэнд-систему/базу данных.

## 7. Вопросы безопасности

*   **Валидация ввода:** `app.py` и компоненты UI должны выполнять базовую валидацию пользовательского ввода (например, проверку обязательных полей, как реализовано в `app.py` перед запуском подбора).
*   **Обработка ошибок:** Реализована корректная обработка ошибок (например, `try-except` блоки при загрузке данных/моделей в `app.py` и при работе с API).
*   **Ключи внешних API:** Ключи API для внешних сервисов (OpenAI, Яндекс.Карты) должны управляться безопасно через переменные окружения (например, с использованием `python-dotenv`, как это может быть настроено в `src/utils/request_api.py` или `src/utils/utils.py`). **Необходимо убедиться, что `.env` файл не попадает в систему контроля версий.**